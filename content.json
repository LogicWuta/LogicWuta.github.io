{"pages":[],"posts":[{"title":"spring注解","text":"最近面试笔试常问到spring的注解，在这里整理了一下。 容器声明注解@Component 泛指组件，组件不好归类时可以使用。 @Service 标注业务逻辑层组件。 @Repository 标注数据访问层组件。 @Controller 标注控制层层组件。 注入bean的注解@Autowired 自动装配注解，其作用是为了消除Java代码里面的getter/setter与bean属性中的property。@Autowired默认按类型匹配的方式查找匹配的Bean，当且仅有一个匹配的Bean时，Spring将其注入@AutoWired标注的变量中。默认按照byType方式进行bean匹配，查找不到对应容器会抛出NoSuchBeanDefinitionException。可以将注解的required属性设为false,Spring容器不再抛出异常而是认为属性为null（尚未理解，是指容器属性为null吗）。 @Qualifier 指定bean名称注入,如果有一个以上匹配的bean，可以通过注解@Qualifier(“bean_id”)限定bean。 @Resource 与@Autowired相似，默认通过name属性去匹配bean，找不到再按type匹配。可以通过设置注解name，type的其中一个或两个属性去匹配bean，不匹配将报错。 @Resource 时j2ee注解，@Autowired和@Qualifier是Spring注解。 java配置类相关注解@Configuration 声明当前类为配置类，相当于xml形式的Spring配置。其中内部组合了Component注解，表面这个类是一个bean。 @Bean 注解在方法上，声明当前方法的返回值为一个bean，替代xml中的方式。 @ComponentScan 用于对Component进行扫描，替代xml中的方式（类上）。 @WishlyConfiguration @Configuration和@ComponentScan的组合注解。 AOP相关注解@Aspect 声明一个切面（类上），使用@After、@Before、@Around定义advice，课直接将切点作为参数。 @PointCut 声明切点，在java配置类中使用@EnableAspectJAutoProxy注解开启Spring对AspectJ代理的支持（类上）。 @After 在方法执行之后执行。 @Around 在方法执行之前和之后执行 @Before 在方法执行之前执行。（这3个都定义在方法上） bean属性支持@Scope 设置Spring容器创建Bean实例的方式（方法上，需要@Bean注解），设置类型包括：1，Singleton 单例，默认模式，只有一个bean实例。2，Protetype 每次调用新建一个bean。3，Session web项目中给每个http session新建一个bean。4，GlobeSession 给每一个 global http session新建一个bean。 @StepScope 在Spring Batch中还有涉及。（不了解） @PostConstruct 由JSR-250提供，在构造函数执行完之后执行，等价于xml配置文件中bean的initMethod。 @PreDestroy 由JSR-250提供，在Bean销毁之前执行，等价于xml配置文件中bean的destroyMethod.Value注解为属性注值，支持如下方式注入值：1，注入字符 @Value(“Nemo”)String name;2，注入操作系统属性 @Value(“#{systemProperties[‘os.name’]}”)String osName;3， 注入表达式结果 @Value(“#{T(java.lang.Math).random()}”)String randomNumber;4, 注入其他bean属性 @Value(“#{domeClass.name}”)String name;5, 注入文件资源 @Value(“classpath:com/hgs/hello/text.txt”)String Resource file;6, 注入网站资源 @Value(“http://www.baidu.com&quot;)Resource url;7，注入配置文件 @Value(“${book.name}}”)String bookName，使用配置要先编写配置文件.properties文件，如test.properties。在使用@PropertySource 加载配置文件，@PropertySource(“classpath:com/hgs/hello/test/test.properties”)(类上)，还需要配置一个PropertySourceConfigurer的bean。 环境切换@Profile 通过设定Environment的ActiveProfiles来设定当前context需要使用的配置环境。（类或方法上） @Conditional Spring4中可以使用此注解定义条件化的bean，通过实现Condition接口，并重写matches方法，从而决定该bean是否被实例化。 异步相关@EnableAsync 配置类中，通过此注解开启对异步任务的支持，叙事性AsyncConfigurer接口（类上） @Async 在实际执行的bean方法使用该注解来申明其是一个异步任务（方法上或类上所有的方法都将异步，需要@EnableAsync开启异步任务） 定时任务相关@EnableScheduling 在配置类上使用，开启计划任务的支持（类上） @Scheduled 来申明这是一个任务，包括cron,fixDelay,fixRate等类型（方法上，需先开启计划任务的支持） Enable*注解说明@EnableAspectJAutoProxy 开启对AspectJ自动代理的支持 @EnableAsync 开启异步方法的支持 @EnableScheduling 开启计划任务的支持 @EnableWebMvc 开启Web MVC的配置支持 @EnableConfigurationProperties 开启对@ConfigurationProperties注解配置Bean的支持 @EnableJpaRepositories 开启对SpringData JPA Repository的支持 @EnableTransactionManagement 开启注解式事务的支持 @EnableCaching 开启注解式的缓存支持 测试相关注解@RunWith 运行器，Spring中通常用于对JUnit的支持 @RunWith(SpringJUnit4ClassRunner.class) @ContextConfiguration 用来加载配置ApplicationContext，其中classes属性用来加载配置类 @ContextConfiguration(classes={TestConfig.class}) SpringMVC部分 @EnableWebMvc 在配置类中开启Web MVC的配置支持，如一些ViewResolver或者MessageConverter等，若无此句，重写WebMvcConfigurerAdapter方法（用于对SpringMVC的配置）。 @Controller 声明该类为SpringMVC中的Controller @RequestMapping 用于映射Web请求，包括访问路径和参数（类或方法上） @ResponseBody 支持将返回值放在response内，而不是一个页面，通常用户返回json数据（返回值旁或方法上） @RequestBody 允许request的参数在request体中，而不是在直接连接在地址后面。（放在参数前） @PathVariable 用于接收路径参数，比如@RequestMapping(“/hello/{name}”)申明的路径，将注解放在参数中前，即可获取该值，通常作为Restful的接口实现方法。 @RestController 该注解为一个组合注解，相当于@Controller和@ResponseBody的组合，注解在类上，意味着，该Controller的所有方法都默认加上了@ResponseBody。 @ControllerAdvice 通过该注解，我们可以将对于控制器的全局配置放置在同一个位置，注解了@Controller的类的方法可使用@ExceptionHandler、@InitBinder、@ModelAttribute注解到方法上， 这对所有注解了 @RequestMapping的控制器内的方法有效。 @ExceptionHandler 用于全局处理控制器里的异常 @InitBinder 用来设置WebDataBinder，WebDataBinder用来自动绑定前台请求参数到Model中。 @ModelAttribute 本来的作用是绑定键值对到Model里，在@ControllerAdvice中是让全局的@RequestMapping都能获得在此处设置的键值对。 以上内容整理自网络，如有遗漏或有误的地方，希望帮忙指出。","link":"/2019/10/01/spring注解/"},{"title":"firstBlog","text":"博客测试A test,hello blog. 改写博客后部署GitHub失败在修改博客后需执行hexo clean清理之前生成的文件。再执行hexo start重新生成文件，退出输入hexo d即可部署。 hexo start errorERROR Process failed: _posts/firstBlog.mdTypeError: Cannot read property ‘utcOffset’ of null blog目录下的_config.yml文件中设置的timezone与主题的配置文件中不一致。修改一致后解决。","link":"/2019/09/23/firstBlog/"},{"title":"建达笔试面试","text":"流程面试前需要先做一份笔试题。笔试题比较基础，但考得相当细。面试完之后会有小哥过来技术面，根据试卷问相关问题，再谈一谈你做的项目。之后是主管面试，谈一下你会的项目和框架，然后就是上家的工资，再问你对公司的看法或者疑问。 笔试笔试其实是比较简单的，不过本人才疏学浅，做的一般。10道选择题，10道看代码，3道算法，6道数据库，2道简单题。总体比较基础，但考很多细节。看代码写输出个人感觉是最难的。 算法偏简单，题目如下：写一个函数将输入的字符串倒序输出。写一个函数实现计算1+12+22+…+n2。写一个函数实现身份证号的校验，15位或18位，最后一位可为字母，输出出生日期。忘了还有一道前端题，写一个下拉框，点击下拉框中的属性可使文本框内出现这个属性值。 数据库常规,多表查询，join,group by,order by,count。 简答题：session和cookies的异同点。Java序列化的作用。 面试面试分两轮，技术面和主管面。技术面主要会在试卷算法题和数据库题上面拓展。小哥问了我算法第二题可以用递归吗？还有我做的项目里的数据库设计，开发流程，增加论坛的二级回复功能怎么实现。","link":"/2019/09/25/建达笔试面试-1/"}],"tags":[{"name":"spring","slug":"spring","link":"/tags/spring/"},{"name":"interview","slug":"interview","link":"/tags/interview/"},{"name":"注解","slug":"注解","link":"/tags/注解/"},{"name":"java interview","slug":"java-interview","link":"/tags/java-interview/"}],"categories":[]}